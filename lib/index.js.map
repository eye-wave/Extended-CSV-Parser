{
  "version": 3,
  "sources": ["../src/parser.ts"],
  "sourcesContent": ["export function parseCSV(input: string, customTypes: CustomTypeDefinition[] = []) {\n  input = input.replace(/#.*\\n?/g, \"\").trim()\n  const [rawHeaders] = input.match(/.*/) || []\n\n  if (!rawHeaders) throw new Error(\"File empty\")\n\n  const schema = getSchemaFromCSV(rawHeaders)\n  const rows = input.split(\"\\n\").slice(1)\n\n  return rows.map(row => parseRowWithSchema(row, schema, customTypes))\n}\n\nexport type CustomTypeDefinition = {\n  name: string\n  parse: (input: string) => unknown\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction parseItemWithType(input: string, type: string, customTypes: CustomTypeDefinition[] = []): any {\n  if (type.endsWith(\"[]\")) {\n    const nestedType = type.slice(0, -2)\n    return input\n      .split(\";\")\n      .map(item => parseItemWithType(item, nestedType))\n      .filter(item => {\n        if (typeof item === \"string\" && item.length < 1) return false\n        if (typeof item === \"number\" && item === 0) return true\n        if (typeof item === \"boolean\" && item === false) return true\n        if (!item) return false\n        return true\n      })\n  }\n\n  const n = input.startsWith(\"0x\") ? parseInt(input) : parseFloat(input)\n\n  switch (type) {\n    case \"float\":\n    case \"number\":\n      return isNaN(n) ? null : n\n    case \"int\":\n      return isNaN(n) ? null : Math.floor(n)\n    case \"bool\":\n    case \"boolean\": {\n      const lower = input.toLowerCase()\n      if (lower === \"true\") return true\n      if (lower === \"false\") return false\n      return null\n    }\n  }\n\n  for (const typedef of customTypes) {\n    if (type !== typedef.name) continue\n    return typedef.parse(input)\n  }\n\n  return input\n}\n\nfunction parseRowWithSchema(row: string, schema: Schema, customTypes: CustomTypeDefinition[] = []) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const obj: any = {}\n\n  row.split(\",\").forEach((item, i) => {\n    const schemaItem = schema.at(i)\n\n    if (!schemaItem) return\n\n    const nested = schemaItem.tokens.slice(0, -1)\n    const lastToken = schemaItem.tokens.at(-1)\n    const parsedItem = parseItemWithType(item, schemaItem.type, customTypes)\n\n    if (parsedItem === null) return\n\n    if (!lastToken) return\n\n    let nestedObject = obj\n    nested.forEach(token => {\n      if (!(token in nestedObject)) nestedObject[token] = {}\n      nestedObject = nestedObject[token]\n    })\n\n    nestedObject[lastToken] = parsedItem\n  })\n\n  return obj\n}\n\ntype Schema = SchemaItem[]\ntype SchemaItem = {\n  type: string\n  tokens: string[]\n}\n\nfunction getSchemaFromCSV(input: string): Schema {\n  return input.split(\",\").map(item => {\n    const [rawToken, type = \"string\"] = item.split(\":\")\n    const tokens = rawToken?.split(\".\") || []\n\n    return { type, tokens }\n  })\n}\n"],
  "mappings": "AAAO,SAASA,EAASC,EAAeC,EAAsC,CAAC,EAAG,CAChFD,EAAQA,EAAM,QAAQ,UAAW,EAAE,EAAE,KAAK,EAC1C,GAAM,CAACE,CAAU,EAAIF,EAAM,MAAM,IAAI,GAAK,CAAC,EAE3C,GAAI,CAACE,EAAY,MAAM,IAAI,MAAM,YAAY,EAE7C,IAAMC,EAASC,EAAiBF,CAAU,EAG1C,OAFaF,EAAM,MAAM;AAAA,CAAI,EAAE,MAAM,CAAC,EAE1B,IAAIK,GAAOC,EAAmBD,EAAKF,EAAQF,CAAW,CAAC,CACrE,CAQA,SAASM,EAAkBP,EAAeQ,EAAcP,EAAsC,CAAC,EAAQ,CACrG,GAAIO,EAAK,SAAS,IAAI,EAAG,CACvB,IAAMC,EAAaD,EAAK,MAAM,EAAG,EAAE,EACnC,OAAOR,EACJ,MAAM,GAAG,EACT,IAAIU,GAAQH,EAAkBG,EAAMD,CAAU,CAAC,EAC/C,OAAOC,GACF,OAAOA,GAAS,UAAYA,EAAK,OAAS,EAAU,GACpD,OAAOA,GAAS,UAAYA,IAAS,GACrC,OAAOA,GAAS,WAAaA,IAAS,GAAc,GACnD,EAAAA,CAEN,EAGL,IAAM,EAAIV,EAAM,WAAW,IAAI,EAAI,SAASA,CAAK,EAAI,WAAWA,CAAK,EAErE,OAAQQ,EAAM,CACZ,IAAK,QACL,IAAK,SACH,OAAO,MAAM,CAAC,EAAI,KAAO,EAC3B,IAAK,MACH,OAAO,MAAM,CAAC,EAAI,KAAO,KAAK,MAAM,CAAC,EACvC,IAAK,OACL,IAAK,UAAW,CACd,IAAMG,EAAQX,EAAM,YAAY,EAChC,OAAIW,IAAU,OAAe,GACzBA,IAAU,QAAgB,GACvB,IACT,CACF,CAEA,QAAWC,KAAWX,EACpB,GAAIO,IAASI,EAAQ,KACrB,OAAOA,EAAQ,MAAMZ,CAAK,EAG5B,OAAOA,CACT,CAEA,SAASM,EAAmBD,EAAaF,EAAgBF,EAAsC,CAAC,EAAG,CAEjG,IAAMY,EAAW,CAAC,EAElB,OAAAR,EAAI,MAAM,GAAG,EAAE,QAAQ,CAACK,EAAMI,IAAM,CAClC,IAAMC,EAAaZ,EAAO,GAAGW,CAAC,EAE9B,GAAI,CAACC,EAAY,OAEjB,IAAMC,EAASD,EAAW,OAAO,MAAM,EAAG,EAAE,EACtCE,EAAYF,EAAW,OAAO,GAAG,EAAE,EACnCG,EAAaX,EAAkBG,EAAMK,EAAW,KAAMd,CAAW,EAIvE,GAFIiB,IAAe,MAEf,CAACD,EAAW,OAEhB,IAAIE,EAAeN,EACnBG,EAAO,QAAQI,GAAS,CAChBA,KAASD,IAAeA,EAAaC,CAAK,EAAI,CAAC,GACrDD,EAAeA,EAAaC,CAAK,CACnC,CAAC,EAEDD,EAAaF,CAAS,EAAIC,CAC5B,CAAC,EAEML,CACT,CAQA,SAAST,EAAiBJ,EAAuB,CAC/C,OAAOA,EAAM,MAAM,GAAG,EAAE,IAAIU,GAAQ,CAClC,GAAM,CAACW,EAAUb,EAAO,QAAQ,EAAIE,EAAK,MAAM,GAAG,EAC5CY,GAASD,GAAA,YAAAA,EAAU,MAAM,OAAQ,CAAC,EAExC,MAAO,CAAE,KAAAb,EAAM,OAAAc,CAAO,CACxB,CAAC,CACH",
  "names": ["parseCSV", "input", "customTypes", "rawHeaders", "schema", "getSchemaFromCSV", "row", "parseRowWithSchema", "parseItemWithType", "type", "nestedType", "item", "lower", "typedef", "obj", "i", "schemaItem", "nested", "lastToken", "parsedItem", "nestedObject", "token", "rawToken", "tokens"]
}
